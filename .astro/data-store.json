[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.16.7","content-config-digest","897d0aa003aa68be","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,49,50],"announcing-lsp-analysis-skill",{"id":11,"data":13,"body":22,"filePath":23,"digest":24,"rendered":25,"legacyId":48},{"title":14,"description":15,"publishedAt":16,"tags":17,"readingMinutes":21},"Announcing LSP Analysis Skill","Equipping AI agents with compiler-accurate code understanding via LSAP.",["Date","2026-01-09T00:00:00.000Z"],[18,19,20],"Release","Skills","LSAP",4,"We are excited to introduce the **LSP Analysis Skill** (v1.0.0-alpha), a new capability designed to bridge the gap between AI agents and professional-grade code intelligence.\n\nThis skill equips agents with the [Language Server Agent Protocol (LSAP)](/references/LSAP), enabling them to navigate, understand, and analyze codebases with the same fidelity as a human developer using an IDE.\n\n## IntelliSense for Agents\n\nMost current agents rely on text search (grep) or file reading to understand code. This is error-prone and lacks context. The LSP Analysis Skill changes this by giving agents access to **compiler-accurate** information.\n\nInstead of guessing, agents can now:\n- **Jump to Definition**: Precisely locate where symbols are defined.\n- **Find References**: See exactly where functions and classes are used across the entire workspace.\n- **Inspect Types**: Understand data structures without needing to read the full implementation.\n\n## Key Capabilities\n\nThe skill provides a set of \"Cognitive Capabilities\" that wrap standard LSP operations:\n\n-   **ğŸ” Semantic Navigation**: Understands code structure (Classes, Functions, Variables) rather than just text patterns.\n-   **ğŸ·ï¸ Language-Awareness**: Eliminates false positives by distinguishing between identically named symbols in different scopes.\n-   **ğŸ”— Cross-File Intelligence**: Safely refactor and trace dependencies across multiple files.\n-   **ğŸ—ºï¸ Symbol Outlines**: Generate high-level maps of files to grasp architecture quickly.\n\n## Extensible Design\n\nWe built this skill to grow with the ecosystem. It features a three-tier extensibility design:\n\n-   **Foundation**: Built on `lsp-client`, supporting a wide range of languages (Python, Rust, TypeScript, Go, etc.).\n-   **Protocol**: Powered by **LSAP**, which continuously adds new composed capabilities like Relation API and Impact Analysis.\n-   **Best Practices**: A modular system allowing community contributions for domain-specific workflows (e.g., `bp_frontend.md`, `bp_django.md`).\n\n## Getting Started\n\nThe skill wraps the `lsp` command line tool and manages the lifecycle of language servers automatically. When an agent invokes it, the skill converts fuzzy intents into precise file coordinates and returns optimized Markdown snapshots.\n\nCheck out the [Skill Documentation](/references/lsp-skill/README) to learn more about how to integrate this into your agent workflow.","src/content/blog/latest-update.md","abc883f4fbdf86a9",{"html":26,"metadata":27},"\u003Cp>We are excited to introduce the \u003Cstrong>LSP Analysis Skill\u003C/strong> (v1.0.0-alpha), a new capability designed to bridge the gap between AI agents and professional-grade code intelligence.\u003C/p>\n\u003Cp>This skill equips agents with the \u003Ca href=\"/references/LSAP\">Language Server Agent Protocol (LSAP)\u003C/a>, enabling them to navigate, understand, and analyze codebases with the same fidelity as a human developer using an IDE.\u003C/p>\n\u003Ch2 id=\"intellisense-for-agents\">IntelliSense for Agents\u003C/h2>\n\u003Cp>Most current agents rely on text search (grep) or file reading to understand code. This is error-prone and lacks context. The LSP Analysis Skill changes this by giving agents access to \u003Cstrong>compiler-accurate\u003C/strong> information.\u003C/p>\n\u003Cp>Instead of guessing, agents can now:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cstrong>Jump to Definition\u003C/strong>: Precisely locate where symbols are defined.\u003C/li>\n\u003Cli>\u003Cstrong>Find References\u003C/strong>: See exactly where functions and classes are used across the entire workspace.\u003C/li>\n\u003Cli>\u003Cstrong>Inspect Types\u003C/strong>: Understand data structures without needing to read the full implementation.\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"key-capabilities\">Key Capabilities\u003C/h2>\n\u003Cp>The skill provides a set of â€œCognitive Capabilitiesâ€ that wrap standard LSP operations:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cstrong>ğŸ” Semantic Navigation\u003C/strong>: Understands code structure (Classes, Functions, Variables) rather than just text patterns.\u003C/li>\n\u003Cli>\u003Cstrong>ğŸ·ï¸ Language-Awareness\u003C/strong>: Eliminates false positives by distinguishing between identically named symbols in different scopes.\u003C/li>\n\u003Cli>\u003Cstrong>ğŸ”— Cross-File Intelligence\u003C/strong>: Safely refactor and trace dependencies across multiple files.\u003C/li>\n\u003Cli>\u003Cstrong>ğŸ—ºï¸ Symbol Outlines\u003C/strong>: Generate high-level maps of files to grasp architecture quickly.\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"extensible-design\">Extensible Design\u003C/h2>\n\u003Cp>We built this skill to grow with the ecosystem. It features a three-tier extensibility design:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cstrong>Foundation\u003C/strong>: Built on \u003Ccode>lsp-client\u003C/code>, supporting a wide range of languages (Python, Rust, TypeScript, Go, etc.).\u003C/li>\n\u003Cli>\u003Cstrong>Protocol\u003C/strong>: Powered by \u003Cstrong>LSAP\u003C/strong>, which continuously adds new composed capabilities like Relation API and Impact Analysis.\u003C/li>\n\u003Cli>\u003Cstrong>Best Practices\u003C/strong>: A modular system allowing community contributions for domain-specific workflows (e.g., \u003Ccode>bp_frontend.md\u003C/code>, \u003Ccode>bp_django.md\u003C/code>).\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"getting-started\">Getting Started\u003C/h2>\n\u003Cp>The skill wraps the \u003Ccode>lsp\u003C/code> command line tool and manages the lifecycle of language servers automatically. When an agent invokes it, the skill converts fuzzy intents into precise file coordinates and returns optimized Markdown snapshots.\u003C/p>\n\u003Cp>Check out the \u003Ca href=\"/references/lsp-skill/README\">Skill Documentation\u003C/a> to learn more about how to integrate this into your agent workflow.\u003C/p>",{"headings":28,"localImagePaths":42,"remoteImagePaths":43,"frontmatter":44,"imagePaths":47},[29,33,36,39],{"depth":30,"slug":31,"text":32},2,"intellisense-for-agents","IntelliSense for Agents",{"depth":30,"slug":34,"text":35},"key-capabilities","Key Capabilities",{"depth":30,"slug":37,"text":38},"extensible-design","Extensible Design",{"depth":30,"slug":40,"text":41},"getting-started","Getting Started",[],[],{"slug":11,"title":14,"description":15,"publishedAt":45,"tags":46,"readingMinutes":21},["Date","2026-01-09T00:00:00.000Z"],[18,19,20],[],"latest-update.md","why-lsp-for-agents",{"id":49,"data":51,"body":60,"filePath":61,"digest":62,"rendered":63,"legacyId":98},{"title":52,"description":53,"publishedAt":54,"tags":55,"readingMinutes":59},"Why LSP is a Great Substrate for Coding Agents","From symbol graphs to semantic navigation: why regex is not enough and what agents get 'for free' with LSP.",["Date","2026-01-05T00:00:00.000Z"],[56,57,58],"LSP","Agents","Architecture",8,"If you are building a Coding Agent today, you have two choices for how your agent perceives code: **Text** or **Structure**.\n\nMost early agents treated code as text. They used `grep` to find functions, regex to extract signatures, and file overwrites to apply changes. This works for small scripts, but in large repositories, \"Text\" is a lie. A function named `save()` might appear in 50 files; `grep` cannot tell you which one is relevant to the `User` class you are refactoring.\n\nTo build agents that can reliably navigate and modify enterprise-scale codebases, we need a source of truth. We need the **Language Server Protocol (LSP)**.\n\n## The \"Grep\" Trap\n\nImagine asking an agent to \"Rename `User.validate` to `User.verify`\".\n\nA text-based agent might:\n1. Search for the string \"validate\".\n2. Find 200 matches across `user.py`, `data_validator.py`, and comments.\n3. Try to guess which ones belong to the `User` class based on surrounding lines.\n4. Apply a regex replace.\n\nThe result? Broken imports, renamed comments, and subtle bugs where a local variable named `validate` inside a totally unrelated function got renamed.\n\n## LSP: Deterministic Handles to Meaning\n\nLSP changes the game because it operates on **symbols**, not text. It provides what we call \"deterministic handles to code meaning.\"\n\n### 1. \"Where things are\" (Definitions & References)\nInstead of searching for a string, an agent using LSP asks: *\"Where is the definition of the symbol at line 10, character 5?\"*\n\nThe server replies with a precise location. When the agent asks for \"References,\" it gets a list of *actual usages*â€”filtering out comments, strings, and identically named methods in other classes. This is the difference between an agent that *guesses* and an agent that *knows*.\n\n### 2. \"What things are\" (Hover & Types)\nLSP provides type information \"for free.\" An agent can inspect a variable and know it's an instance of `SQLAlchemy.Session` without reading the import paths or parsing the file header. This allows the agent to hallucinate less and use correct APIs more often.\n\n### 3. \"How to change them\" (Workspace Edits)\nPerhaps the most powerful feature for agents is `WorkspaceEdit`. instead of rewriting files blindly, LSP allows agents to calculate a precise patch.\n\n```typescript\n// A safe, atomic rename operation\nconst edit = await client.rename({\n  textDocument: { uri: \"file:///src/models.py\" },\n  position: { line: 10, character: 5 },\n  newName: \"verify\"\n});\n```\n\nThis edit object encapsulates changes across multiple files. The agent can \"dry run\" this edit, check for conflicts, and apply it atomically.\n\n## The Gap: Atomic vs. Cognitive\n\nWhile LSP is the perfect *substrate*, it wasn't designed for agentsâ€”it was designed for IDEs. This creates an \"Impedance Mismatch.\"\n\nLSP primitives are **Atomic**:\n- `textDocument/definition`\n- `textDocument/hover`\n- `textDocument/documentSymbol`\n\nAgent intents are **Cognitive**:\n- \"Find all implementations of the `Auth` interface.\"\n- \"Understand how data flows from the API controller to the database.\"\n\nIf an agent uses raw LSP, it has to act like a frantic human clicking around an editor: *Jump to def -> Read file -> Find usage -> Jump again -> Read file*. This burns tokens and context window rapidly.\n\n### The Need for an Orchestration Layer\n\nThis is where protocols like **LSAP (Language Server Agent Protocol)** come in. By wrapping LSP's atomic operations into higher-level cognitive tools, we can give agents the best of both worlds:\n\n1.  **The Precision of LSP**: No more regex guessing.\n2.  **The High-Level Intent of Agents**: Single requests that perform complex graph traversals.\n\nFor example, an LSAP-enabled agent can request a \"Reference Report,\" and the protocol layer handles the dozens of underlying LSP jumps, returning a synthesized Markdown summary of *relevant* code.\n\n## Conclusion\n\nLSP solved the $M \\times N$ problem for editors (M editors, N languages). For agents, it solves the **Grounding Problem**. It anchors LLM hallucinations to the rigid reality of the compiler/interpreter.\n\nIf you are building a coding agent, don't write another regex parser. Stand on the shoulders of the decade of work that went into LSP. Your agent (and your users) will thank you.","src/content/blog/why-lsp-for-agents.md","3f0832b5cd703dea",{"html":64,"metadata":65},"\u003Cp>If you are building a Coding Agent today, you have two choices for how your agent perceives code: \u003Cstrong>Text\u003C/strong> or \u003Cstrong>Structure\u003C/strong>.\u003C/p>\n\u003Cp>Most early agents treated code as text. They used \u003Ccode>grep\u003C/code> to find functions, regex to extract signatures, and file overwrites to apply changes. This works for small scripts, but in large repositories, â€œTextâ€ is a lie. A function named \u003Ccode>save()\u003C/code> might appear in 50 files; \u003Ccode>grep\u003C/code> cannot tell you which one is relevant to the \u003Ccode>User\u003C/code> class you are refactoring.\u003C/p>\n\u003Cp>To build agents that can reliably navigate and modify enterprise-scale codebases, we need a source of truth. We need the \u003Cstrong>Language Server Protocol (LSP)\u003C/strong>.\u003C/p>\n\u003Ch2 id=\"the-grep-trap\">The â€œGrepâ€ Trap\u003C/h2>\n\u003Cp>Imagine asking an agent to â€œRename \u003Ccode>User.validate\u003C/code> to \u003Ccode>User.verify\u003C/code>â€.\u003C/p>\n\u003Cp>A text-based agent might:\u003C/p>\n\u003Col>\n\u003Cli>Search for the string â€œvalidateâ€.\u003C/li>\n\u003Cli>Find 200 matches across \u003Ccode>user.py\u003C/code>, \u003Ccode>data_validator.py\u003C/code>, and comments.\u003C/li>\n\u003Cli>Try to guess which ones belong to the \u003Ccode>User\u003C/code> class based on surrounding lines.\u003C/li>\n\u003Cli>Apply a regex replace.\u003C/li>\n\u003C/ol>\n\u003Cp>The result? Broken imports, renamed comments, and subtle bugs where a local variable named \u003Ccode>validate\u003C/code> inside a totally unrelated function got renamed.\u003C/p>\n\u003Ch2 id=\"lsp-deterministic-handles-to-meaning\">LSP: Deterministic Handles to Meaning\u003C/h2>\n\u003Cp>LSP changes the game because it operates on \u003Cstrong>symbols\u003C/strong>, not text. It provides what we call â€œdeterministic handles to code meaning.â€\u003C/p>\n\u003Ch3 id=\"1-where-things-are-definitions--references\">1. â€œWhere things areâ€ (Definitions &#x26; References)\u003C/h3>\n\u003Cp>Instead of searching for a string, an agent using LSP asks: \u003Cem>â€œWhere is the definition of the symbol at line 10, character 5?â€\u003C/em>\u003C/p>\n\u003Cp>The server replies with a precise location. When the agent asks for â€œReferences,â€ it gets a list of \u003Cem>actual usages\u003C/em>â€”filtering out comments, strings, and identically named methods in other classes. This is the difference between an agent that \u003Cem>guesses\u003C/em> and an agent that \u003Cem>knows\u003C/em>.\u003C/p>\n\u003Ch3 id=\"2-what-things-are-hover--types\">2. â€œWhat things areâ€ (Hover &#x26; Types)\u003C/h3>\n\u003Cp>LSP provides type information â€œfor free.â€ An agent can inspect a variable and know itâ€™s an instance of \u003Ccode>SQLAlchemy.Session\u003C/code> without reading the import paths or parsing the file header. This allows the agent to hallucinate less and use correct APIs more often.\u003C/p>\n\u003Ch3 id=\"3-how-to-change-them-workspace-edits\">3. â€œHow to change themâ€ (Workspace Edits)\u003C/h3>\n\u003Cp>Perhaps the most powerful feature for agents is \u003Ccode>WorkspaceEdit\u003C/code>. instead of rewriting files blindly, LSP allows agents to calculate a precise patch.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"typescript\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">// A safe, atomic rename operation\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">const\u003C/span>\u003Cspan style=\"color:#79B8FF\"> edit\u003C/span>\u003Cspan style=\"color:#F97583\"> =\u003C/span>\u003Cspan style=\"color:#F97583\"> await\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> client.\u003C/span>\u003Cspan style=\"color:#B392F0\">rename\u003C/span>\u003Cspan style=\"color:#E1E4E8\">({\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  textDocument: { uri: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"file:///src/models.py\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> },\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  position: { line: \u003C/span>\u003Cspan style=\"color:#79B8FF\">10\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, character: \u003C/span>\u003Cspan style=\"color:#79B8FF\">5\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> },\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  newName: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"verify\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">});\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>This edit object encapsulates changes across multiple files. The agent can â€œdry runâ€ this edit, check for conflicts, and apply it atomically.\u003C/p>\n\u003Ch2 id=\"the-gap-atomic-vs-cognitive\">The Gap: Atomic vs. Cognitive\u003C/h2>\n\u003Cp>While LSP is the perfect \u003Cem>substrate\u003C/em>, it wasnâ€™t designed for agentsâ€”it was designed for IDEs. This creates an â€œImpedance Mismatch.â€\u003C/p>\n\u003Cp>LSP primitives are \u003Cstrong>Atomic\u003C/strong>:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Ccode>textDocument/definition\u003C/code>\u003C/li>\n\u003Cli>\u003Ccode>textDocument/hover\u003C/code>\u003C/li>\n\u003Cli>\u003Ccode>textDocument/documentSymbol\u003C/code>\u003C/li>\n\u003C/ul>\n\u003Cp>Agent intents are \u003Cstrong>Cognitive\u003C/strong>:\u003C/p>\n\u003Cul>\n\u003Cli>â€œFind all implementations of the \u003Ccode>Auth\u003C/code> interface.â€\u003C/li>\n\u003Cli>â€œUnderstand how data flows from the API controller to the database.â€\u003C/li>\n\u003C/ul>\n\u003Cp>If an agent uses raw LSP, it has to act like a frantic human clicking around an editor: \u003Cem>Jump to def -> Read file -> Find usage -> Jump again -> Read file\u003C/em>. This burns tokens and context window rapidly.\u003C/p>\n\u003Ch3 id=\"the-need-for-an-orchestration-layer\">The Need for an Orchestration Layer\u003C/h3>\n\u003Cp>This is where protocols like \u003Cstrong>LSAP (Language Server Agent Protocol)\u003C/strong> come in. By wrapping LSPâ€™s atomic operations into higher-level cognitive tools, we can give agents the best of both worlds:\u003C/p>\n\u003Col>\n\u003Cli>\u003Cstrong>The Precision of LSP\u003C/strong>: No more regex guessing.\u003C/li>\n\u003Cli>\u003Cstrong>The High-Level Intent of Agents\u003C/strong>: Single requests that perform complex graph traversals.\u003C/li>\n\u003C/ol>\n\u003Cp>For example, an LSAP-enabled agent can request a â€œReference Report,â€ and the protocol layer handles the dozens of underlying LSP jumps, returning a synthesized Markdown summary of \u003Cem>relevant\u003C/em> code.\u003C/p>\n\u003Ch2 id=\"conclusion\">Conclusion\u003C/h2>\n\u003Cp>LSP solved the $M \\times N$ problem for editors (M editors, N languages). For agents, it solves the \u003Cstrong>Grounding Problem\u003C/strong>. It anchors LLM hallucinations to the rigid reality of the compiler/interpreter.\u003C/p>\n\u003Cp>If you are building a coding agent, donâ€™t write another regex parser. Stand on the shoulders of the decade of work that went into LSP. Your agent (and your users) will thank you.\u003C/p>",{"headings":66,"localImagePaths":92,"remoteImagePaths":93,"frontmatter":94,"imagePaths":97},[67,70,73,77,80,83,86,89],{"depth":30,"slug":68,"text":69},"the-grep-trap","The â€œGrepâ€ Trap",{"depth":30,"slug":71,"text":72},"lsp-deterministic-handles-to-meaning","LSP: Deterministic Handles to Meaning",{"depth":74,"slug":75,"text":76},3,"1-where-things-are-definitions--references","1. â€œWhere things areâ€ (Definitions & References)",{"depth":74,"slug":78,"text":79},"2-what-things-are-hover--types","2. â€œWhat things areâ€ (Hover & Types)",{"depth":74,"slug":81,"text":82},"3-how-to-change-them-workspace-edits","3. â€œHow to change themâ€ (Workspace Edits)",{"depth":30,"slug":84,"text":85},"the-gap-atomic-vs-cognitive","The Gap: Atomic vs. Cognitive",{"depth":74,"slug":87,"text":88},"the-need-for-an-orchestration-layer","The Need for an Orchestration Layer",{"depth":30,"slug":90,"text":91},"conclusion","Conclusion",[],[],{"slug":49,"title":52,"description":53,"publishedAt":95,"tags":96,"readingMinutes":59},["Date","2026-01-05T00:00:00.000Z"],[56,57,58],[],"why-lsp-for-agents.md"]